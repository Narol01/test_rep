package practice.complexity;

import java.util.Arrays;

public class ComplexityAppl {
    public static void main(String[] args) {
        //заведем массив целых чисел
        //будем выполнять с ним различные элементы
        //оценим вычеслительную сложность алгоритма
        int[] arr = {-24, 7, -67, 15, 8, 93, 1};

        /*
        вычесление среднего значения
        узнать длину масива
        в цикле складываем элементы
        сумму делим на количевство элементов масива
        */
        int sum = 0;
        for (int i = 0; i < arr.length; i++) {
            sum += arr[i];//здесь растёт количевство операций
        }
        double avg = (double) sum / arr.length;//ккастинг в другой тип данных
        System.out.println(avg);
        //что будет происходить при росте количевства элементов масива?
        //это линейная сложность-так как количевство операций прямо пропорциональна количевству элементов массива
        //0(n) - это вычеслительная сложность

        //поиск элемента
        //если идём по массиву то это линейная сложность - так как количевство операций прямо пропорциональна количевству элементов массива
        //если бинарный поиск
       // Arrays.sort(arr); //отдельная вычеслительная мощность
//        System.out.println(Arrays.toString(arr));
//        int index = Arrays.binarySearch(arr, -67);
//        System.out.println(index);
//        index = Arrays.binarySearch(arr, 93);
//        System.out.println(index);
//        index = Arrays.binarySearch(arr, -100);
//        System.out.println(index);

        //при 8 элементах - 3 иттерации деления масива
        //при 16 элементах - 4 иттерации деления масива
        //при 1024 элементах - 10 иттерации деления масива
        //2048 элементов -11 иттераций деления элементов
        //О (log(n)) - это логарефмическая сложность(самая низкая)

        //сортировка методом баблсорт сравниваем по два элемента текущий (i) и следующтй(i+1)
        for (int i = 0; i < arr.length - 1; i++) {
            for (int j = 0; j < arr.length - 1-i; j++) {
                if (arr[j] > arr[j + 1]) {
                    //перестановкка элемента местами
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
        Arrays.sort(arr); //отдельная вычеслительная мощность
        System.out.println(Arrays.toString(arr));
        // сложность в методе сорт достигнута полилинейная
    }
}
